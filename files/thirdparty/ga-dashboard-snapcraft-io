#!/usr/bin/env python

"""Google Analytics to Prometheus metrics exporter.

Based on the Google Analytics Reporting API v4 Python quickstart:
https://developers.google.com/analytics/devguides/reporting/core/v4/quickstart/service-py.

Check the online API docs:
https://developers.google.com/analytics/devguides/reporting/core/v4/rest/v4/reports/batchGet

the interactive API explorer:
https://developers.google.com/apis-explorer/#p/analyticsreporting/v4/analyticsreporting.reports.batchGet.

and the dimensions & metrics explorer:
https://developers.google.com/analytics/devguides/reporting/core/dimsmets

"""

import configparser
import httplib2
import logging
import os
import sys

from apiclient.discovery import build

if '--debug' in sys.argv:
    logging.basicConfig(level=logging.DEBUG)
    httplib2.debuglevel = 1

try:
    from oauth2client.service_account import ServiceAccountCredentials
except ImportError:
    logging.info('Using backported ServiceAccountCredentials')
    from service_account import ServiceAccountCredentials

from prometheus_client import CollectorRegistry, Gauge, push_to_gateway

# Explicit discovery URI for backwards compatibility with older versions
# of python-googleapi.
V2_DISCOVERY_URI = ('https://{api}.googleapis.com/$discovery/rest?'
                    'version={apiVersion}')


def get_config(pkg, name):
    """
    Get configuration options for this script
    """
    config = configparser.SafeConfigParser()
    conffiles = [
        '/etc/{}.ini'.format(pkg),
        os.path.expanduser('~/.{}.ini'.format(pkg)),
        '{}.ini'.format(pkg),
    ]
    config.read(conffiles)
    return config[name]


def initialize_analyticsreporting(
        creds_path, scopes, http_proxy=None, https_proxy=None):
    """Initializes an analyticsreporting service object.

    Returns: analytics an authorized analyticsreporting service object.
    """
    credentials = ServiceAccountCredentials.from_json_keyfile_name(
        creds_path, scopes=scopes)

    proxy = None
    if https_proxy:
        logging.info('Using https_proxy: %s', https_proxy)
        proxy = httplib2.proxy_info_from_url(https_proxy, 'https')
    elif http_proxy:
        logging.info('Using http_proxy: %s', http_proxy)
        proxy = httplib2.proxy_info_from_url(http_proxy, 'http')
    if proxy:
        # Force remote DNS resolution through the proxy (default behaviour
        # in newer releases of httplib2).
        proxy.proxy_rdns = True

    http = credentials.authorize(httplib2.Http(proxy_info=proxy))

    # Build the service object.
    analytics = build(
        'analytics', 'v4', http=http, discoveryServiceUrl=V2_DISCOVERY_URI)

    return analytics


def get_report(analytics, view_id, since):
    # Use the Analytics Service Object to query the Analytics Reporting API V4.
    return analytics.reports().batchGet(
        body={
            'reportRequests': [{
                'viewId': view_id,
                'dateRanges': [{
                    'startDate': since,
                    'endDate': 'today',
                }],
                'metrics': [
                    {'expression': 'ga:sessions'},
                    {'expression': 'ga:newUsers'},
                    {'expression': 'ga:users'},
                ],
                'dimensions': [
                    {'name': 'ga:source'},
                ],
            }]
        }).execute()


def set_gauges(registry, response):
    """Parses and prints the Analytics Reporting API V4 response"""

    for report in response.get('reports', []):
        columnHeader = report.get('columnHeader', {})
        dimensionHeaders = columnHeader.get('dimensions', [])
        metricHeader = columnHeader.get('metricHeader', {})
        metricHeaders = metricHeader.get('metricHeaderEntries', [])
        rows = report.get('data', {}).get('rows', [])

        # Dynamically create gauges based on the API query response.
        gauges = {}
        for metric in metricHeaders:
            metric_name = metric['name'].replace('ga:', '')
            gauge = Gauge(
                name='ga_dashboard_snapcraft_io_{}'.format(metric_name),
                documentation='GA metric for dashboard.snapcraft.io {}'.format(
                    metric_name),
                labelnames=[d.replace('ga:', '') for d in dimensionHeaders],
                registry=registry)
            gauges[metric['name']] = gauge

        for row in rows:
            dimensions = row.get('dimensions', [])
            dimensions = [
                x.encode('ascii', errors='replace') for x in dimensions]
            dateRangeValues = row.get('metrics', [])

            for i, values in enumerate(dateRangeValues):
                values = values.get('values')

                for metricHeader, value in zip(metricHeaders, values):
                    metric_name = metricHeader.get('name')
                    value = int(value)

                    gauges[metric_name].labels(*dimensions).set(value)


def main():
    pkg = 'snappy-kpi-scripts'
    name = os.path.basename(sys.argv[0])
    config = get_config(pkg, name)

    registry = CollectorRegistry()
    try:
        view_id = config['ga-dashboard-snapcraft-io-view-id']
        creds_path = config['ga-dashboard-snapcraft-io-credentials-file']
        scopes = ['https://www.googleapis.com/auth/analytics.readonly']

        analytics = initialize_analyticsreporting(
            creds_path, scopes, config.get('http_proxy'),
            config.get('https_proxy'))
        # Get historical, all-time total counters.
        response = get_report(analytics, view_id, '2010-01-01')
        set_gauges(registry, response)

    except:
        logging.exception('Error processing metrics')
    finally:
        if '--debug' not in sys.argv:
            # if set_gauges bombed out for any reason, just upload blank data.
            push_to_gateway(
                config['push-gateway'],
                job='google_analytics',
                registry=registry)
        else:  # Debugging enabled.
            import pprint
            pprint.pprint([(x.name, x.samples) for x in registry.collect()])


if __name__ == '__main__':
    sys.exit(main())
